function g(n){if(!n||typeof n!="string")throw new Error("Invalid URI: must be a string");const o=n.trim();if(!o.startsWith("otpauth://"))throw new Error("Invalid URI: must start with otpauth://");let e;try{e=new URL(o)}catch{throw new Error("Invalid URI: malformed URL")}const s=e.hostname.toLowerCase();if(s!=="totp"&&s!=="hotp")throw new Error(`Unsupported OTP type: ${s}`);const r=decodeURIComponent(e.pathname.slice(1));let i="",a=r;if(r.includes(":")){const m=r.indexOf(":");i=r.slice(0,m).trim(),a=r.slice(m+1).trim()}const t=e.searchParams;t.get("issuer")&&(i=t.get("issuer"));const c=t.get("secret");if(!c)throw new Error("Invalid URI: missing secret parameter");const l=(t.get("algorithm")||"SHA1").toUpperCase(),p=parseInt(t.get("digits")||"6",10),d=parseInt(t.get("period")||"30",10);return{type:s,issuer:i||a.split("@")[1]||"Unknown",account:a,secret:c.replace(/\s/g,"").toUpperCase(),algorithm:l,digits:isNaN(p)?6:p,period:isNaN(d)?30:d}}function h(n){const{issuer:o,account:e,secret:s,algorithm:r="SHA1",digits:i=6,period:a=30}=n,t=o?`${encodeURIComponent(o)}:${encodeURIComponent(e)}`:encodeURIComponent(e),c=new URLSearchParams({secret:s,issuer:o,algorithm:r,digits:String(i),period:String(a)});return`otpauth://totp/${t}?${c.toString()}`}export{h as generateOtpauthURI,g as parseOtpauthURI};
